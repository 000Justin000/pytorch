from typing import List, Tuple
import inspect
import ast

from .ops import *


# Function variants definitions
# TODO: link back to op class with decorator or attribute


# Types
supported_types = {"TensorList", "Tensor", "MutatedTensorA"}

cpp_template = r"""
#include <ATen/ATen.h>
#include <c10/util/Exception.h>

// NOTICE! This file is autogenerated!

namespace at {{ namespace native {{

{function_cpp}

}}}} // at::native
"""

# cpp print helpers
def map_type_to_cpp(type):
    if type == "TensorList":
        return "TensorList"
    elif type == "Tensor":
        return "Tensor"
    elif type == "MutatedTensorA":
        return "Tensor&"

    assert False, "Unknown type to map to cpp!"

def print_arg_cpp(arg):
    return map_type_to_cpp(arg.type) + " " + arg.name

# Base class for representing all Python nodes
class _Statement(object):
    def __init__(self, stmt):
        super().__init__()

        self.stmt = stmt

type_to_class_map = {}

# An assignment
# https://greentreesnakes.readthedocs.io/en/latest/nodes.html?highlight=assign#Assign
class _Assign(_Statement):
    def __init__(self, stmt):
        super().__init__(stmt)

        assert isinstance(stmt, ast.Assign)
        assert len(stmt.targets) == 1
        self.targets = parse_stmt(stmt.targets[0])
        self.value = parse_stmt(stmt.value)

        self.fields = ('targets', 'value')

    # TODO: don't auto all new variables
    def __str__(self):
        return "auto " + str(self.targets) + " = " + str(self.value)


# Attribute access, like foo.bar
# https://docs.python.org/3/library/ast.html?highlight=attribute#ast.Attribute
class _Attribute(_Statement):
    def __init__(self, stmt):
        super().__init__(stmt)

        assert isinstance(stmt, ast.Attribute)
        self.value = parse_stmt(stmt.value)
        self.attr = stmt.attr  # attr is a string
        self.ctx = stmt.ctx  # ctx is load/store/del

        self.fields = ('value', 'attr', 'ctx')

    def __str__(self):
        # TODO: allow other namespaces
        # translates torch calls to at::
        s = None
        if str(self.value) == "torch":
            s = "at::" + self.attr
        else:
            s = str(self.value) + "." + self.attr

        if type(self.ctx) == ast.Load:
            s += "()"

        return s

# A function call
# https://greentreesnakes.readthedocs.io/en/latest/nodes.html?highlight=call#Call
class _Call(_Statement):
    def __init__(self, stmt):
        super().__init__(stmt)
        assert isinstance(stmt, ast.Call)

        self.func = parse_stmt(stmt.func)
        # args and keywords can be empty lists
        # TODO: map out-of-order Python calls to CPP
        self.args = tuple(map(parse_stmt, stmt.args),)
        self.keywords = tuple(map(parse_stmt, stmt.keywords),)
        # TODO: handle starargs

        self.fields = ('func', 'args', 'keywords')

    def __str__(self):
        # TORCH_CHECK is a special-cased prim
        if str(self.func) == "TORCH_CHECK":
            return "TORCH_CHECK(" + ", ".join(map(str, self.args)) + ")"

        # Note: The func_name may have a () because of how attributes
        #   are printed in the load ctx
        func_name = str(self.func).replace('()', '')
        s = func_name

        # special-cases out by assuming it's the first argument
        # TODO: FIXME
        if len(self.keywords) > 0:
            # TODO: handle more kwargs than out=
            # TODO: don't assume the out arg is always named "result"
            # TODO: don't assume that the out variant is always named _out
            assert len(self.keywords) == 1
            kwarg = self.keywords[0]
            assert kwarg.arg == "out"
            s += "_out(result, "
        else:
            s += "("


        s += ", ".join(map(str, self.args)) + ")"

        return s

# A comparison of two or more values
# https://docs.python.org/3/library/ast.html?highlight=compare#ast.Compare
class _Compare(_Statement):
    def __init__(self, stmt):
        super().__init__(stmt)

        assert isinstance(stmt, ast.Compare)
        self.left = parse_stmt(stmt.left)  # first value in the comparison
        assert len(stmt.ops) == 1
        self.op = parse_stmt(stmt.ops[0])
        assert len(stmt.comparators) == 1
        self.right = parse_stmt(stmt.comparators[0])

        self.fields = ('left', 'op', 'right')

    def __str__(self):
        return str(self.left) + " " + str(self.op) + " " + str(self.right)

# A constant value
# https://docs.python.org/3/library/ast.html?highlight=constant#ast.Constant
class _Constant(_Statement):
    def __init__(self, stmt):
        super().__init__(stmt)
        assert isinstance(stmt, ast.Constant)

        self.value = parse_stmt(stmt.value)
        self.fields = ('value',)

    def __str__(self):
        return str(self.value)

# A function call by itself
# https://greentreesnakes.readthedocs.io/en/latest/nodes.html#expressions
class _Expr(_Statement):
    def __init__(self, stmt):
        super().__init__(stmt)

        assert isinstance(stmt, ast.Expr)
        self.value = parse_stmt(stmt.value)

        self.fields = ('value',)

    def __str__(self):
        return str(self.value)

# Greater than operator
# https://docs.python.org/3/library/ast.html?highlight=gt#ast.Gt
class _Gt(_Statement):
    def __init__(self, stmt):
        super().__init__(stmt)
        assert isinstance(stmt, ast.Gt)

    def __str__(self):
        return ">"


# An integer
# https://docs.python.org/3/library/functions.html?highlight=int#int
class _Int(_Statement):
    def __init__(self, stmt):
        super().__init__(stmt)
        assert isinstance(stmt, int)

        self.value = stmt

    def __str__(self):
        return str(self.value)

# A keyword argument to a function call or class definition
# https://docs.python.org/3/library/ast.html?highlight=keyword#ast.keyword
class _Keyword(_Statement):
    def __init__(self, stmt):
        super().__init__(stmt)
        assert isinstance(stmt, ast.keyword)

        self.arg = stmt.arg  # a str
        self.value = parse_stmt(stmt.value)

        self.fields = ('arg', 'value',)

    def __str__(self):
        return self.arg + "=" + str(self.value)

# TODO: support typed names
# A variable name
# https://docs.python.org/3/library/ast.html?highlight=name#ast.Name
class _Name(_Statement):
    def __init__(self, stmt):
        super().__init__(stmt)

        assert isinstance(stmt, ast.Name)
        self.id = stmt.id  # string name
        # ctx is one of Load, Store, Del
        self.ctx = stmt.ctx

        self.fields = ('id', 'ctx')

    def __str__(self):
        return self.id

# A return statement
# https://greentreesnakes.readthedocs.io/en/latest/nodes.html?highlight=return#Return
class _Return(_Statement):
    def __init__(self, stmt):
        super().__init__(stmt)

        assert isinstance(stmt, ast.Return)
        self.value = parse_stmt(stmt.value)

        self.fields = ('value',)

    def __str__(self):
        return "return " + str(self.value)


# A Python string
class _String(_Statement):
    def __init__(self, stmt):
        super().__init__(stmt)
        assert isinstance(stmt, str)

        self.value = stmt

    def __str__(self):
        return '"' + self.value + '"'

type_to_class_map_impl = {
    ast.Assign : _Assign,
    ast.Attribute : _Attribute,
    ast.Call : _Call,
    ast.Compare : _Compare,
    ast.Constant : _Constant,
    ast.Expr : _Expr,
    ast.Gt : _Gt,
    int : _Int,
    ast.keyword : _Keyword,
    ast.Name : _Name,
    ast.Return : _Return,
    str : _String,
}

type_to_class_map.update(type_to_class_map_impl)

def parseBody(body):
    stmts = []
    for stmt in body:
        stmts.append(type_to_class_map[type(stmt)](stmt))

    return stmts

# def cppify_helper(parent, child):
#     if not isinstance(child, _Statement):
#         return

#     # maps len() calls to .size() attribute accesses
#     if isinstance(child, _Call):
#         if str(child.func) == "len":
#             for field in parent.fields:
#                 if getattr(parent, field) == child:
#                     size_access = _Attribute(
#                         ast.Attribute(
#                             value=child.args[0].stmt,
#                             attr="size",
#                             ctx=ast.Load()))
#                     setattr(parent, field, size_access)
#                     return

#     if not hasattr(child, 'fields'):
#         return

#     for field in child.fields:
#         attr = getattr(child, field)

#         if isinstance(attr, Tuple) or isinstance(attr, List):
#             for a in attr:
#                 cppify_helper(child, a)
#         else:
#             cppify_helper(child, attr)

# Converts Python statements into C++ equivalents where necessary
def cppify(stmts):
    for stmt in stmts:
        cppify_helper(None, stmt)


# TODO: update to global state
class _ScopeManager(object):
    def __init__(self, native_functions):
        super().__init__()

        self._name_counter = 0
        self._var_name_counter = 0

        self.cur_scope = {
            "_name": self._name_counter,
            "_depth": 0,
            "_parent": None,
            "_children": []
        }

        self.native_functions = native_functions

    def start_scope(self):
        self._name_counter = self._name_counter + 1
        scope = {
            "_name": self._name_counter,
            "_depth": self.cur_scope["_depth"] + 1,
            "_parent": self.cur_scope,
            "_children": []
        }

        self.cur_scope["_children"].append(scope)
        self.cur_scope = scope

    def close_scope(self):
        self.cur_scope = self.cur_scope["_parent"]

    def add_variable(self, name: str, type: str):
        # TODO update scope modeling so these names are separated
        #   from variable names and not reserved
        assert name != "_name"
        assert name != "_depth"
        assert name != "_parent"
        assert name != "_children"

        self.cur_scope[name] = type

    def add_anonymous_variable(self, type: str):
        name = "var" + str(self._name_counter)
        self._name_counter = self._name_counter + 1

        return name

    def _get_variable_type_helper(self, name: str, scope):
        typ = getattr(scope, name, None)
        if typ is not None:
            return typ

        parent = scope["_parent"]
        if parent is None:
            return None

        return self._get_variable_type_helper(name, parent)

    def get_variable_type(self, name: str):
        return self._get_variable_type_helper(name, self.cur_scope)

    def get_depth(self):
        return self.cur_scope["_depth"]

def parse_binop(stmt: ast.AST):
    if isinstance(stmt, ast.Add):
        return "+"

    assert False, "Unknown binary op {0}".format(type(stmt))

def parse_unaryop(stmt: ast.AST):
    if isinstance(stmt, ast.USub):
        return "-"

    assert False, "Unknown unary op {0}".format(type(stmt))

def parse_constant(stmt: ast.AST):
    assert isinstance(stmt, ast.Constant)

    val = stmt.value

    if isinstance(val, str):
        return "{0}".format(val), "string"
    elif isinstance(val, float):
        return str(val), "float"
    elif isinstance(val, int):
        return str(val), "int"
    elif isinstance(val, complex):
        return str(val), "complex"

    assert False, "Unknown constant type {0}".format(type(val))

def parse_name(stmt: ast.AST):
    assert isinstance(stmt, ast.Name)

    name: str = stmt.id

    # TODO: ctx is ignored
    ctx = stmt.ctx

    # TODO: handle annotated names
    typ = None

    return name, typ

def parse_function_call(stmt: ast.AST, sm: _ScopeManager):
    # TODO: support fluent interfaces by not assuming the attribute
    #   access is on a name
    # TODO: support method access and namespaces other than Torch
    if isinstance(stmt, ast.Attribute):
        name, typ = parse_name(stmt.value)
        func_name = stmt.attr

        # TODO: working here on supporting call mapping to C++
        for nf in sm.native_functions:
            if nf.func.name.name.base == func_name:
                print(nf)


        if name == "torch":
            return "at::" + stmt.attr


    assert False, "Unknown functional call {0}".format(type(stmt))


# Transforms a Python AST node into multiple C++ statements in
#   SSA form and returns a tuple (src, (name, type)) (name, type) is a
#   pair representing the output of the operation and src is the additional C++
#   statements, in SSA form, that produce the output.
# TODO: consider supporting multiple output statements
def cppify_stmt(stmt: ast.AST, sm: _ScopeManager):
    stmts = []

    # An assignment
    # https://greentreesnakes.readthedocs.io/en/latest/nodes.html?highlight=assign#Assign
    if isinstance(stmt, ast.Assign):
        assert len(stmt.targets) == 1
        # Assumes the lhs of the assignment is a name
        lhs, lhs_typ = parse_name(stmt.targets[0])
        rhs_src, (rhs, rhs_typ) = cppify_stmt(stmt.value, sm)

        # TODO: validate lhs_type and rhs_type
        # TODO: validate type consistency

        existing_typ = sm.get_variable_type(lhs)

        # TODO: support reassignment
        assert existing_typ is None

        sm.add_variable(lhs, rhs_typ)

        src = "\t" * sm.get_depth() + lhs + " = " + rhs

        return rhs_src + (src,), (lhs, rhs_typ)
    # A binary operation, like add or sub
    #https://greentreesnakes.readthedocs.io/en/latest/nodes.html?highlight=binop#BinOp
    if isinstance(stmt, ast.BinOp):
        lhs_src, (lhs, lhs_type) = cppify_stmt(stmt.left, sm)
        rhs_src, (rhs, rhs_type) = cppify_stmt(stmt.right, sm)
        op_str = parse_binop(stmt.op)

        # TODO: type propagate to determine result type
        name = sm.add_anonymous_variable(None)

        src = "\t" * sm.get_depth() + "auto " + name + " = " + lhs + " " + op_str + " " + rhs


        return rhs_src + lhs_src + (src,), (name, None)

        # sm.add_variable(target[1][0])
    # A function call
    # https://greentreesnakes.readthedocs.io/en/latest/nodes.html?highlight=call#Call
    if isinstance(stmt, ast.Call):
        # TODO: handle *args and **kwargs
        # NOTE: in Python positional arguments may not follow keyword args
        # First verifies all args are constants or names
        final_args = []
        src = []
        for arg in stmt.args:
            if isinstance(arg, ast.Name):
                name, typ = parse_name(arg)
                final_args.append(name)
            elif isinstance(arg, ast.Constant):
                name, typ = parse_constant(arg)
                final_args.append(name)
            else:
                arg_src, (name, typ) = cppify_stmt(arg, sm)
                src.extend(arg_src)
                final_args.append(name)

        final_kwargs = []
        for kwarg in stmt.keywords:
            assert isinstance(kwarg, ast.keyword)
            if isinstance(kwarg.value, ast.Name):
                name, typ = parse_name(kwarg.value)
                final_args.append((kwarg.arg, name))
            elif isinstance(kwarg.value, ast.Constant):
                name, typ = parse_constant(kwarg.value)
                final_args.append((kwarg.arg, name))
            else:
                arg_src, (name, typ) = cppify_stmt(kwarg.value, sm)
                src.extend(arg_src)
                final_args.append((kwarg.arg, name))

        func_str = parse_function_call(stmt.func, sm)

        # TODO: type validation
        # TODO: perform kwarg surgery

        # TODO: this is wrong depending on if the call is alone or inline
        # TODO: is that what expression is for?
        call_src = "\t" * sm.get_depth() + func_str + "(ARGS)"
        return tuple(src), (call_src, None)

    #     func =
    # A constant value
    # https://docs.python.org/3/library/ast.html?highlight=constant#ast.Constant
    elif isinstance(stmt, ast.Constant):
        value, typ = parse_constant(stmt)
        return (), (value, typ)
    # # A function call by itself
    # # https://greentreesnakes.readthedocs.io/en/latest/nodes.html#expressions
    # elif isinstance(stmt, ast.Expr):
    #     pass
    # # TODO: support typed names
    # # A variable name
    # # https://docs.python.org/3/library/ast.html?highlight=name#ast.Name
    # elif isinstance(stmt, ast.Name):
    #     name: str = stmt.id
    #     ctx = stmt.ctx  # ctx is one of Load, Store, Del
    #     return (name, ((name, None),))
    # A unary operation
    # https://greentreesnakes.readthedocs.io/en/latest/nodes.html?highlight=unaryop#UnaryOp
    elif isinstance(stmt, ast.UnaryOp):
        op_str = parse_unaryop(stmt.op)
        operand_src, (operand_name, operand_typ) = cppify_stmt(stmt.operand, sm)

        # TODO: type propagate to determine result type
        name = sm.add_anonymous_variable(None)

        src = "\t" * sm.get_depth() + "auto " + name + " = " + op_str + operand_name

        return operand_src + (src,), (name, None)

    assert False, "Unknown expression type {0}".format(type(stmt))

def write_pyops_cpp(native_functions):
    # src = "t = torch.tensor(1)\ntorch.add(t, alpha=2, other=-1)"
    # src = "t = torch.tensor(1)"
    src = "t = torch.add(t, alpha=2, other=-1)"
    tree = ast.parse(src)

    stmts = tree.body
    sm = _ScopeManager(native_functions)

    cpp_stmts = []
    for stmt in stmts:
        cpp_source = cppify_stmt(stmt, sm)
        cpp_stmts.append(cpp_source)

    # cppify(root)

    # cpp = ""

    # for op in pyops_sequence:
    #     src = inspect.getsource(op)
    #     tree = ast.parse(src)

    #     # asserts the tree is a single FunctionDef node
    #     assert len(tree.body) == 1
    #     fn_node = tree.body[0]

    #     # constructs the signature
    #     sig = parseSignature(fn_node)

    #     name = sig.name.replace("__", "_")
    #     cpp_type = map_type_to_cpp(sig.type)
    #     cpp = cpp + "{0} {1}(".format(cpp_type, name)

    #     l = []
    #     for arg in sig.args:
    #         l.append(print_arg_cpp(arg))

    #     # TODO: handle kwargs other than out=
    #     for kwarg in sig.kwargs:
    #         assert kwarg.name == "out"
    #         l.append("Tensor& result")

    #     cpp = cpp + ", ".join(l) + ") {\n"

    #     # constructs the body
    #     body_list = fn_node.body
    #     parsed_body = parseBody(body_list)
    #     cppify(parsed_body)

    #     # TODO: add adjustable indentation level
    #     for stmt in parsed_body:
    #         cpp = cpp + "\t" + str(stmt) + ";\n"

    #     # prints closing curly brace
    #     cpp += "}\n\n"

    #     # print(cpp)

    # cpp = cpp_template.format(function_cpp=cpp)

    # if path is not None:
    #     _write_if_changed(path, cpp)
    # else:
    #     return cpp

    # import sys
    # import importlib
    # tools_root = "/private/home/mruberry/git/pytorch/tools/"
    # sys.path.insert(0, tools_root)
    # importlib.import_module("tools.codegen")
    # from tools.codegen import parse_native_yaml

    return cpp_stmts
