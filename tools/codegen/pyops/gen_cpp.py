from typing import Sequence, List, SupportsAbs, Tuple, Dict, Union, Optional
import inspect
import ast
from enum import Enum
import numbers
import itertools

from tools.codegen.pyops import pyops_builtins
from tools.codegen.pyops.ops import *
from tools.codegen.model import (
    Type, ListType, BaseType, BaseTy, 
)

# # Function variants definitions
# # TODO: link back to op class with decorator or attribute


# # Types
# supported_types = {"TensorList", "Tensor", "MutatedTensorA"}

# cpp_template = r"""
# #include <ATen/ATen.h>
# #include <c10/util/Exception.h>

# // NOTICE! This file is autogenerated!

# namespace at {{ namespace native {{

# {function_cpp}

# }}}} // at::native
# """

# # cpp print helpers
# def map_type_to_cpp(type):
#     if type == "TensorList":
#         return "TensorList"
#     elif type == "Tensor":
#         return "Tensor"
#     elif type == "MutatedTensorA":
#         return "Tensor&"

#     assert False, "Unknown type to map to cpp!"

# def print_arg_cpp(arg):
#     return map_type_to_cpp(arg.type) + " " + arg.name

# # Base class for representing all Python nodes
# class _Statement(object):
#     def __init__(self, stmt):
#         super().__init__()

#         self.stmt = stmt

# type_to_class_map = {}

# # An assignment
# # https://greentreesnakes.readthedocs.io/en/latest/nodes.html?highlight=assign#Assign
# class _Assign(_Statement):
#     def __init__(self, stmt):
#         super().__init__(stmt)

#         assert isinstance(stmt, ast.Assign)
#         assert len(stmt.targets) == 1
#         self.targets = parse_stmt(stmt.targets[0])
#         self.value = parse_stmt(stmt.value)

#         self.fields = ('targets', 'value')

#     # TODO: don't auto all new variables
#     def __str__(self):
#         return "auto " + str(self.targets) + " = " + str(self.value)


# # Attribute access, like foo.bar
# # https://docs.python.org/3/library/ast.html?highlight=attribute#ast.Attribute
# class _Attribute(_Statement):
#     def __init__(self, stmt):
#         super().__init__(stmt)

#         assert isinstance(stmt, ast.Attribute)
#         self.value = parse_stmt(stmt.value)
#         self.attr = stmt.attr  # attr is a string
#         self.ctx = stmt.ctx  # ctx is load/store/del

#         self.fields = ('value', 'attr', 'ctx')

#     def __str__(self):
#         # TODO: allow other namespaces
#         # translates torch calls to at::
#         s = None
#         if str(self.value) == "torch":
#             s = "at::" + self.attr
#         else:
#             s = str(self.value) + "." + self.attr

#         if type(self.ctx) == ast.Load:
#             s += "()"

#         return s

# # A function call
# # https://greentreesnakes.readthedocs.io/en/latest/nodes.html?highlight=call#Call
# class _Call(_Statement):
#     def __init__(self, stmt):
#         super().__init__(stmt)
#         assert isinstance(stmt, ast.Call)

#         self.func = parse_stmt(stmt.func)
#         # args and keywords can be empty lists
#         # TODO: map out-of-order Python calls to CPP
#         self.args = tuple(map(parse_stmt, stmt.args),)
#         self.keywords = tuple(map(parse_stmt, stmt.keywords),)
#         # TODO: handle starargs

#         self.fields = ('func', 'args', 'keywords')

#     def __str__(self):
#         # TORCH_CHECK is a special-cased prim
#         if str(self.func) == "TORCH_CHECK":
#             return "TORCH_CHECK(" + ", ".join(map(str, self.args)) + ")"

#         # Note: The func_name may have a () because of how attributes
#         #   are printed in the load ctx
#         func_name = str(self.func).replace('()', '')
#         s = func_name

#         # special-cases out by assuming it's the first argument
#         # TODO: FIXME
#         if len(self.keywords) > 0:
#             # TODO: handle more kwargs than out=
#             # TODO: don't assume the out arg is always named "result"
#             # TODO: don't assume that the out variant is always named _out
#             assert len(self.keywords) == 1
#             kwarg = self.keywords[0]
#             assert kwarg.arg == "out"
#             s += "_out(result, "
#         else:
#             s += "("


#         s += ", ".join(map(str, self.args)) + ")"

#         return s

# # A comparison of two or more values
# # https://docs.python.org/3/library/ast.html?highlight=compare#ast.Compare
# class _Compare(_Statement):
#     def __init__(self, stmt):
#         super().__init__(stmt)

#         assert isinstance(stmt, ast.Compare)
#         self.left = parse_stmt(stmt.left)  # first value in the comparison
#         assert len(stmt.ops) == 1
#         self.op = parse_stmt(stmt.ops[0])
#         assert len(stmt.comparators) == 1
#         self.right = parse_stmt(stmt.comparators[0])

#         self.fields = ('left', 'op', 'right')

#     def __str__(self):
#         return str(self.left) + " " + str(self.op) + " " + str(self.right)


# class _Constant(_Statement):
#     def __init__(self, stmt):
#         super().__init__(stmt)
#         assert isinstance(stmt, ast.Constant)

#         self.value = parse_stmt(stmt.value)
#         self.fields = ('value',)

#     def __str__(self):
#         return str(self.value)


# class _Expr(_Statement):
#     def __init__(self, stmt):
#         super().__init__(stmt)

#         assert isinstance(stmt, ast.Expr)
#         self.value = parse_stmt(stmt.value)

#         self.fields = ('value',)

#     def __str__(self):
#         return str(self.value)

# # Greater than operator
# # https://docs.python.org/3/library/ast.html?highlight=gt#ast.Gt
# class _Gt(_Statement):
#     def __init__(self, stmt):
#         super().__init__(stmt)
#         assert isinstance(stmt, ast.Gt)

#     def __str__(self):
#         return ">"


# # An integer
# # https://docs.python.org/3/library/functions.html?highlight=int#int
# class _Int(_Statement):
#     def __init__(self, stmt):
#         super().__init__(stmt)
#         assert isinstance(stmt, int)

#         self.value = stmt

#     def __str__(self):
#         return str(self.value)

# # A keyword argument to a function call or class definition
# # https://docs.python.org/3/library/ast.html?highlight=keyword#ast.keyword
# class _Keyword(_Statement):
#     def __init__(self, stmt):
#         super().__init__(stmt)
#         assert isinstance(stmt, ast.keyword)

#         self.arg = stmt.arg  # a str
#         self.value = parse_stmt(stmt.value)

#         self.fields = ('arg', 'value',)

#     def __str__(self):
#         return self.arg + "=" + str(self.value)

# # TODO: support typed names
# # A variable name
# # https://docs.python.org/3/library/ast.html?highlight=name#ast.Name
# class _Name(_Statement):
#     def __init__(self, stmt):
#         super().__init__(stmt)

#         assert isinstance(stmt, ast.Name)
#         self.id = stmt.id  # string name
#         # ctx is one of Load, Store, Del
#         self.ctx = stmt.ctx

#         self.fields = ('id', 'ctx')

#     def __str__(self):
#         return self.id

# # A return statement
# # https://greentreesnakes.readthedocs.io/en/latest/nodes.html?highlight=return#Return
# class _Return(_Statement):
#     def __init__(self, stmt):
#         super().__init__(stmt)

#         assert isinstance(stmt, ast.Return)
#         self.value = parse_stmt(stmt.value)

#         self.fields = ('value',)

#     def __str__(self):
#         return "return " + str(self.value)


# # A Python string
# class _String(_Statement):
#     def __init__(self, stmt):
#         super().__init__(stmt)
#         assert isinstance(stmt, str)

#         self.value = stmt

#     def __str__(self):
#         return '"' + self.value + '"'

# type_to_class_map_impl = {
#     ast.Assign : _Assign,
#     ast.Attribute : _Attribute,
#     ast.Call : _Call,
#     ast.Compare : _Compare,
#     ast.Constant : _Constant,
#     ast.Expr : _Expr,
#     ast.Gt : _Gt,
#     int : _Int,
#     ast.keyword : _Keyword,
#     ast.Name : _Name,
#     ast.Return : _Return,
#     str : _String,
# }

# type_to_class_map.update(type_to_class_map_impl)

# def parseBody(body):
#     stmts = []
#     for stmt in body:
#         stmts.append(type_to_class_map[type(stmt)](stmt))

#     return stmts

# # def cppify_helper(parent, child):
# #     if not isinstance(child, _Statement):
# #         return

# #     # maps len() calls to .size() attribute accesses
# #     if isinstance(child, _Call):
# #         if str(child.func) == "len":
# #             for field in parent.fields:
# #                 if getattr(parent, field) == child:
# #                     size_access = _Attribute(
# #                         ast.Attribute(
# #                             value=child.args[0].stmt,
# #                             attr="size",
# #                             ctx=ast.Load()))
# #                     setattr(parent, field, size_access)
# #                     return

# #     if not hasattr(child, 'fields'):
# #         return

# #     for field in child.fields:
# #         attr = getattr(child, field)

# #         if isinstance(attr, Tuple) or isinstance(attr, List):
# #             for a in attr:
# #                 cppify_helper(child, a)
# #         else:
# #             cppify_helper(child, attr)

# # Converts Python statements into C++ equivalents where necessary
# def cppify(stmts):
#     for stmt in stmts:
#         cppify_helper(None, stmt)


# # TODO: update to global state
# class _ScopeManager(object):
#     def __init__(self, native_functions):
#         super().__init__()

#         self._name_counter = 0
#         self._var_name_counter = 0

#         self.cur_scope = {
#             "_name": self._name_counter,
#             "_depth": 0,
#             "_parent": None,
#             "_children": []
#         }

#         self.native_functions = native_functions

#     def start_scope(self):
#         self._name_counter = self._name_counter + 1
#         scope = {
#             "_name": self._name_counter,
#             "_depth": self.cur_scope["_depth"] + 1,
#             "_parent": self.cur_scope,
#             "_children": []
#         }

#         self.cur_scope["_children"].append(scope)
#         self.cur_scope = scope

#     def close_scope(self):
#         self.cur_scope = self.cur_scope["_parent"]

#     def add_variable(self, name: str, type: str):
#         # TODO update scope modeling so these names are separated
#         #   from variable names and not reserved
#         assert name != "_name"
#         assert name != "_depth"
#         assert name != "_parent"
#         assert name != "_children"

#         self.cur_scope[name] = type

#     def add_anonymous_variable(self, type: str):
#         name = "var" + str(self._name_counter)
#         self._name_counter = self._name_counter + 1

#         return name

#     def _get_variable_type_helper(self, name: str, scope):
#         typ = getattr(scope, name, None)
#         if typ is not None:
#             return typ

#         parent = scope["_parent"]
#         if parent is None:
#             return None

#         return self._get_variable_type_helper(name, parent)

#     def get_variable_type(self, name: str):
#         return self._get_variable_type_helper(name, self.cur_scope)

#     def get_depth(self):
#         return self.cur_scope["_depth"]

# def parse_binop(stmt: ast.AST):
#     if isinstance(stmt, ast.Add):
#         return "+"

#     assert False, "Unknown binary op {0}".format(type(stmt))

# def parse_unaryop(stmt: ast.AST):
#     if isinstance(stmt, ast.USub):
#         return "-"

#     assert False, "Unknown unary op {0}".format(type(stmt))

# def parse_constant(stmt: ast.AST):
#     assert isinstance(stmt, ast.Constant)

#     val = stmt.value

#     if isinstance(val, str):
#         return "{0}".format(val), "string"
#     elif isinstance(val, float):
#         return str(val), "float"
#     elif isinstance(val, int):
#         return str(val), "int"
#     elif isinstance(val, complex):
#         return str(val), "complex"

#     assert False, "Unknown constant type {0}".format(type(val))

# def parse_name(stmt: ast.AST):
#     assert isinstance(stmt, ast.Name)

#     name: str = stmt.id

#     # TODO: ctx is ignored
#     ctx = stmt.ctx

#     # TODO: handle annotated names
#     typ = None

#     return name, typ

# def parse_function_call(stmt: ast.AST, sm: _ScopeManager):
#     # TODO: support fluent interfaces by not assuming the attribute
#     #   access is on a name
#     # TODO: support method access and namespaces other than Torch
#     if isinstance(stmt, ast.Attribute):
#         name, typ = parse_name(stmt.value)
#         func_name = stmt.attr

#         # TODO: working here on supporting call mapping to C++
#         for nf in sm.native_functions:
#             if nf.func.name.name.base == func_name:
#                 print(nf)


#         if name == "torch":
#             return "at::" + stmt.attr


#     assert False, "Unknown functional call {0}".format(type(stmt))


# # Transforms a Python AST node into multiple C++ statements in
# #   SSA form and returns a tuple (src, (name, type)) (name, type) is a
# #   pair representing the output of the operation and src is the additional C++
# #   statements, in SSA form, that produce the output.
# # TODO: consider supporting multiple output statements
# def cppify_stmt(stmt: ast.AST, sm: _ScopeManager):
#     stmts = []

#     # An assignment
#     # https://greentreesnakes.readthedocs.io/en/latest/nodes.html?highlight=assign#Assign
#     if isinstance(stmt, ast.Assign):
#         assert len(stmt.targets) == 1
#         # Assumes the lhs of the assignment is a name
#         lhs, lhs_typ = parse_name(stmt.targets[0])
#         rhs_src, (rhs, rhs_typ) = cppify_stmt(stmt.value, sm)

#         # TODO: validate lhs_type and rhs_type
#         # TODO: validate type consistency

#         existing_typ = sm.get_variable_type(lhs)

#         # TODO: support reassignment
#         assert existing_typ is None

#         sm.add_variable(lhs, rhs_typ)

#         src = "\t" * sm.get_depth() + lhs + " = " + rhs

#         return rhs_src + (src,), (lhs, rhs_typ)
#     # A binary operation, like add or sub
#     #https://greentreesnakes.readthedocs.io/en/latest/nodes.html?highlight=binop#BinOp
#     if isinstance(stmt, ast.BinOp):
#         lhs_src, (lhs, lhs_type) = cppify_stmt(stmt.left, sm)
#         rhs_src, (rhs, rhs_type) = cppify_stmt(stmt.right, sm)
#         op_str = parse_binop(stmt.op)

#         # TODO: type propagate to determine result type
#         name = sm.add_anonymous_variable(None)

#         src = "\t" * sm.get_depth() + "auto " + name + " = " + lhs + " " + op_str + " " + rhs


#         return rhs_src + lhs_src + (src,), (name, None)

#         # sm.add_variable(target[1][0])
#     # A function call
#     # https://greentreesnakes.readthedocs.io/en/latest/nodes.html?highlight=call#Call
#     if isinstance(stmt, ast.Call):
#         # TODO: handle *args and **kwargs
#         # NOTE: in Python positional arguments may not follow keyword args
#         # First verifies all args are constants or names
#         final_args = []
#         src = []
#         for arg in stmt.args:
#             if isinstance(arg, ast.Name):
#                 name, typ = parse_name(arg)
#                 final_args.append(name)
#             elif isinstance(arg, ast.Constant):
#                 name, typ = parse_constant(arg)
#                 final_args.append(name)
#             else:
#                 arg_src, (name, typ) = cppify_stmt(arg, sm)
#                 src.extend(arg_src)
#                 final_args.append(name)

#         final_kwargs = []
#         for kwarg in stmt.keywords:
#             assert isinstance(kwarg, ast.keyword)
#             if isinstance(kwarg.value, ast.Name):
#                 name, typ = parse_name(kwarg.value)
#                 final_args.append((kwarg.arg, name))
#             elif isinstance(kwarg.value, ast.Constant):
#                 name, typ = parse_constant(kwarg.value)
#                 final_args.append((kwarg.arg, name))
#             else:
#                 arg_src, (name, typ) = cppify_stmt(kwarg.value, sm)
#                 src.extend(arg_src)
#                 final_args.append((kwarg.arg, name))

#         func_str = parse_function_call(stmt.func, sm)

#         # TODO: type validation
#         # TODO: perform kwarg surgery

#         # TODO: this is wrong depending on if the call is alone or inline
#         # TODO: is that what expression is for?
#         call_src = "\t" * sm.get_depth() + func_str + "(ARGS)"
#         return tuple(src), (call_src, None)

#     #     func =
#     # A constant value
#     # https://docs.python.org/3/library/ast.html?highlight=constant#ast.Constant
#     elif isinstance(stmt, ast.Constant):
#         value, typ = parse_constant(stmt)
#         return (), (value, typ)
#     # # A function call by itself
#     # # https://greentreesnakes.readthedocs.io/en/latest/nodes.html#expressions
#     # elif isinstance(stmt, ast.Expr):
#     #     pass
#     # # TODO: support typed names
#     # # A variable name
#     # # https://docs.python.org/3/library/ast.html?highlight=name#ast.Name
#     # elif isinstance(stmt, ast.Name):
#     #     name: str = stmt.id
#     #     ctx = stmt.ctx  # ctx is one of Load, Store, Del
#     #     return (name, ((name, None),))
#     # A unary operation
#     # https://greentreesnakes.readthedocs.io/en/latest/nodes.html?highlight=unaryop#UnaryOp
#     elif isinstance(stmt, ast.UnaryOp):
#         op_str = parse_unaryop(stmt.op)
#         operand_src, (operand_name, operand_typ) = cppify_stmt(stmt.operand, sm)

#         # TODO: type propagate to determine result type
#         name = sm.add_anonymous_variable(None)

#         src = "\t" * sm.get_depth() + "auto " + name + " = " + op_str + operand_name

#         return operand_src + (src,), (name, None)

#     assert False, "Unknown expression type {0}".format(type(stmt))

# Supported variable types
# TODO: add all signature types
class popTypes(Enum):
    Unknown = -1
    Nothing = 0
    LiteralBool = 1
    Integer = 2
    LiteralString = 3
    Bool = 4
    String = 5
    Number = 6  # TODO: refine into float/complex
    Tensor = 7
    TensorList = 8

string_to_poptypes_map = {
    "TensorList" : popTypes.TensorList,
}


class popModules(Enum):
    pop_builtins = 1
    torch = 2

# TODO: generate (most of) this programmatically
pop_builtins = {
    'return' : popTypes.Nothing,
    'TORCH_CHECK' : popTypes.Nothing, 
    '>' : popTypes.Bool,
    'len' : popTypes.Number
}


class Variable(object):
    def __init__(self, 
        name: Optional[str], 
        popType: popTypes, *, 
        value: Optional[Union[numbers.Number, str]]=None):
        
        super().__init__()

        self.name = name
        self.popType = popType
        self.value = value


class PopNode(object):
    pass


# TODO: handle inplace ops
# Represents a function call AND the assignment of the results of that function
class PopCall(PopNode):
    def __init__(
        self, 
        popModule: popModules,
        fn_name: str,
        args: Tuple[Variable],
        kwargs: Dict[str, Variable] = {},
        *,
        popType: popTypes,
        store: Optional[Variable]=None):

        if popModule is popModules.pop_builtins:
            assert fn_name in pop_builtins, "Unknown builtin name {0}!".format(fn_name)
    
        self.popModule = popModule
        self.fn_name = fn_name
        self.args = args
        self.kwargs = kwargs
        self.store = store
        self.popType = popType

# a = 3, b = "hi", c = d
class PopAssign(PopNode):
    def __init__(
        self,
        lhs: Variable,
        rhs: Variable
    ):

        self.lhs = lhs
        self.rhs = rhs


class NameState(object):
    def __init__(self, native_functions):
        super().__init__()

        self.native_functions = native_functions

        self._var_name_counter = 0
        self._variables = {}

    def add_variable(self, name: str, popType: popTypes, *, value=None):
        assert name not in self._variables
        assert name not in pop_builtins 

        v = Variable(name, popType, value=value)
        self._variables[name] = v
        return v

    def add_anonymous_variable(self, popType: popTypes, *, value=None):
        name = "v" + str(self._var_name_counter)
        self._var_name_counter = self._var_name_counter + 1
        return self.add_variable(name, popType, value=value)

    def has_variable(self, name: str):
        return name in self._variables

    def get_variable(self, name: str):
        return self._variables[name]

def map_gen_type_to_popType(gen_type: Type) -> popTypes:
    if type(gen_type) is ListType and gen_type.elem.name is BaseTy.Tensor:
        return popTypes.TensorList
    if type(gen_type) is BaseType and gen_type.name is BaseTy.int:
        return popTypes.Integer
    if type(gen_type) is BaseType and gen_type.name is BaseTy.Tensor:
        return popTypes.Tensor

    assert False, "Unknown gen type {0}".format(str(gen_type))
    

# TODO: handle pre_self_positional and self_arg, kwargs, tensor options
# TODO: handle multiple matches
# TODO: handle functions with multiple return values
# Finds a native function matching this call and returns the resequencing
#   of args to call the function in C++ plus the function's type
def match_nf(fn_name: str, args: Sequence[Variable], nfs, *, require_out=False) -> Tuple[Sequence[str], popTypes]:
    matched_nf = None
    for nf in nfs:
        if nf.func.name.name.base == fn_name:
            if require_out:
                if len(nf.func.arguments.out) == 0:
                    continue
            # Attempts to match signature
            matched = True
            for nf_arg, pc_arg in itertools.zip_longest(nf.func.arguments.post_self_positional, args):
                # short-circuits if nf_args are exhausted
                if nf_arg is None:
                    matched = False
                    break

                # short-circuits if pc_args are exhausted and nf_arg has no default
                if pc_arg is None and nf_arg.default is None:
                    matched = False
                    break
                
                # maps arg type to popType
                arg_allowed_popTypes = map_gen_type_to_popType(nf_arg.type)
                
                # short-circuits if types mismatch
                if pc_arg.popType is not arg_allowed_popTypes:
                    matched = False
                    break
                
            if matched:
                matched_nf = nf
                break
        
    assert matched_nf is not None, "Failed to match native function for torch call to {0}!".format(fn_name)
    assert len(matched_nf.func.returns) == 1

    return (), map_gen_type_to_popType(matched_nf.func.returns[0].type)
    

# Map of ast.AST nodes -> parsing functions for those nodes
parse_fn_map = { }

# Converts an AST node into one more PyOpsNodes and returns the Variable containing the
#   computed value of the node (if any) and a tuple of all the PyOpsNodes the AST node was
#   converted into. Updates vs, the given NameState, as a side-effect
def parse_node(node: ast.AST, ns: NameState) -> Tuple[PopNode]:
    return parse_fn_map[type(node)](node, ns)

# A constant value
# https://docs.python.org/3/library/ast.html?highlight=constant#ast.Constant
def parse_constant(node: ast.Constant, ns: NameState) -> Variable:
    if isinstance(node.value, str):
        v = ns.add_anonymous_variable(popTypes.LiteralString, value=node.value)
    elif isinstance(node.value, numbers.Number):
        if isinstance(node.value, numbers.Integral):
            v = ns.add_anonymous_variable(popTypes.Integer, value=node.value)
        else:
            # TODO: refine further than number
            v = ns.add_anonymous_variable(popTypes.Number, value=node.value)
    else:
        assert False, "Unsupported constant type {0}!".format(str(node.value))

    return v

# TODO: support typed names
# A function or variable name
# https://docs.python.org/3/library/ast.html?highlight=name#ast.Name
def parse_name(node: ast.Name, vs: NameState) -> Variable:
    return vs.get_variable(node.id)

# Handles the anonymous assignment of partial results to convert the program to SSA
def ssa(node: ast.AST, ns: NameState, *, store: Optional[str]=None) -> Tuple[Variable, Tuple[PopNode]]:
    # Constants are passed through
    if isinstance(node, ast.Constant):
        c = parse_constant(node, ns)
        if store is None:
            return c, ()

        v = ns.add_variable(store, c.popType)
        return v, (PopAssign(v, c),)

    # Names are passed through
    if isinstance(node, ast.Name):
        assert store is None
        return parse_name(node, ns), ()
    
    # More complicated expressions are assigned as partials
    nodes = parse_node(node, ns)
    last_node = nodes[-1]

    assert isinstance(last_node, PopCall)

    v = None
    if store is None:
        v = ns.add_anonymous_variable(last_node.popType)
    else:
        v = ns.add_variable(store, last_node.popType)
    last_node.store = v

    return v, nodes

# An assignment
# https://greentreesnakes.readthedocs.io/en/latest/nodes.html?highlight=assign#Assign
def parse_assign(node: ast.Call, ns: NameState) -> Tuple[PopNode]:
    assert len(node.targets) == 1

    # Assignments are the only way to introduce a new name into the system
    # This is special-cased by checking if the lhs is an unknown name
    # TODO: support overwriting an existing name
    if isinstance(node.targets[0], ast.Name):
        name = node.targets[0].id
        assert not ns.has_variable(name), "Attempt to write to existing name {0}!".format(name)
        return ssa(node.value, ns, store=name)[1]

    rhs, ssa_rhs = ssa(node.value, ns)

    # LHS is not just a name
    lhs, ssa_lhs = ssa(node.targets[0], ns)
    pna = PopAssign(lhs, rhs)
    return ssa_rhs + ssa_lhs + (pna,)

# Parses a torch function call 
# TODO: acquire torch type
# TODO: support submodules
# TODO: support method calls
def parse_torch_fn(node: ast.Attribute) -> Variable:
    assert isinstance(node.value, ast.Name)
    assert node.value.id == "torch"

    torch_fn: str = node.attr
    return torch_fn, popModules.torch, popTypes.Unknown

# A function call
# https://greentreesnakes.readthedocs.io/en/latest/nodes.html?highlight=call#Call
# TODO: handle starargs
# TODO: extend call support for torch submodules and more Python builtins
def parse_call(node: ast.Call, ns: NameState) -> Tuple[PopNode]:
    
    # Acquires args
    nodes = []
    args = []
    for arg in node.args:
        v, ssa_nodes = ssa(arg, ns)
        args.append(v)
        nodes.extend(ssa_nodes)

    # Acquires kwargs
    kwargs = {}
    for kwarg in node.keywords:
        v, ssa_nodes = ssa(kwarg.value, ns)
        kwargs[kwarg.arg] = v
        nodes.extend(ssa_nodes)

    # Determines the type of call we're dealing with
    fn_name = None
    module = None
    popType: popTypes = popTypes.Unknown
    if isinstance(node.func, ast.Name):
        # builtin
        fn_name = node.func.id
        module = popModules.pop_builtins

        assert fn_name in pop_builtins, "Unknown builtin call {0}!".format(fn_name)
        popType = pop_builtins[fn_name]
    elif isinstance(node.func, ast.Attribute):
        # torch. ...
        fn_name, module, popType = parse_torch_fn(node.func)
        _, popType = match_nf(fn_name, args, ns.native_functions)
    else:
        assert False, "Unknown function {0} called!".format(str(node.func))

    # Adds this node
    pc = PopCall(module, fn_name, args, kwargs, popType=popType)
    nodes.append(pc)

    return tuple(nodes)

# A comparison of two or more values
# https://docs.python.org/3/library/ast.html?highlight=compare#ast.Compare
def parse_compare(node: ast.Compare, vs: NameState) -> Tuple[PopNode]:
    assert len(node.ops) == 1
    assert len(node.comparators) == 1

    rhs, ssa_rhs = ssa(node.comparators[0], vs)
    lhs, ssa_lhs = ssa(node.left, vs)
    

    op = node.ops[0]
    op_name = ""
    if isinstance(op, ast.Gt):
        op_name = ">"
    else:
        assert "Unknown comparator {0}!".format(type(op))

    pc = PopCall(popModules.pop_builtins, op_name, (lhs, rhs), popType=popTypes.Bool)

    return ssa_rhs + ssa_lhs + (pc,)

# A function call by itself
# https://greentreesnakes.readthedocs.io/en/latest/nodes.html#expressions
def parse_expr(node: ast.Expr, ns: NameState) -> Tuple[PopNode]:
    assert isinstance(node.value, ast.Call)
    return parse_node(node.value, ns)


def parse_return(node: ast.Return, ns: NameState) -> Tuple[PopNode]:
    rhs, ssa_rhs = ssa(node.value, ns)
    pc = PopCall(popModules.pop_builtins, 'return', (rhs,), popType=popTypes.Nothing)

    return ssa_rhs + (pc,)


parse_fn_map_impl = { 
    ast.Assign : parse_assign,
    ast.Call : parse_call,
    ast.Compare : parse_compare,
    # ast.Constant : parse_constant,  # must be called explicitly
    ast.Expr : parse_expr,
    # ast.Name : parse_name  # must be called explicitly
    ast.Return : parse_return,
}
parse_fn_map.update(parse_fn_map_impl)


class CPPState(object):
    pass

node_to_cpp_map = {}

def assign_cpp(node: PopAssign, nfs) -> str:
    if node.rhs.value is not None:
        # Literal assignment
        if isinstance(node.rhs.value, numbers.Number):
            return "auto " + node.lhs.name + " = " + str(node.rhs.value)
        elif isinstance(node.rhs.value, str):
            return "auto " + node.lhs.name + " = " + "'" + node.rhs.value + "'"
        else:
            assert "Unknown literal type {0}!".format(type(node.rhs.value))

    # TODO: type lhs like rhs
    return "auto " + node.lhs.name + " = " + node.rhs.name

def _cpp_arg_helper(arg: Variable) -> str:
    if arg.value is not None:
        if isinstance(arg.value, numbers.Number):
            return str(arg.value)
        elif isinstance(arg.value, str):
            return "'" + arg.value + "'"
        
        assert False, "Unknown value type {0}!".format(type(arg.value))

    return arg.name


def call_cpp(node: PopCall, nfs) -> str:
    # TODO: type the variable like the function
    store_str = ""
    if node.store is not None:
        store_str = "auto " + node.store.name + " = "

    # Writes builtin > as C++ builtin >
    if node.fn_name == '>':
        assert len(node.args) == 2
        return store_str + "(" + _cpp_arg_helper(node.args[0]) + " > " + _cpp_arg_helper(node.args[1]) + ")"

    # Converts builtin len to a size member access 
    if node.fn_name == 'len':
        assert len(node.args) == 1
        arg = node.args[0]

        # Validates type
        assert arg.popType is popTypes.TensorList
                
        call_str = arg.name + ".size()"
        return store_str + call_str

    if node.fn_name == 'return':
        assert len(node.args) == 1
        arg = node.args[0]

        return "return " + _cpp_arg_helper(arg)

    # Handles calls to torch functions
    if node.popModule is popModules.torch:
        _, _ = match_nf(node.fn_name, node.args, nfs)
        arg_str = ", ".join(map(_cpp_arg_helper, node.args))
        # Adds kwargs
        if len(node.kwargs) > 0:
            arg_str = arg_str + ", "
            arg_str = arg_str + ", ".join(
                map(lambda item: item[0] + "=" + _cpp_arg_helper(item[1]), 
                    node.kwargs.items()))
                

        call_str = "at::" + node.fn_name + "(" + arg_str + ")"
        return store_str + call_str

    # Generic builtin handling
    arg_str = ", ".join(map(_cpp_arg_helper, node.args))
    call_str = node.fn_name + "(" + arg_str + ")"
    if node.store is None:
        return call_str
    return store_str + call_str


node_to_cpp_map_impl = {
    PopAssign : assign_cpp,
    PopCall : call_cpp,
}
node_to_cpp_map.update(node_to_cpp_map_impl)

def node_to_cpp(node: PopNode, cs: CPPState, nfs) -> str:
    return node_to_cpp_map[type(node)](node, nfs)

def nodes_to_cpp(nodes: Tuple[PopNode], nfs) -> str:
    cpp = []
    cs = CPPState()
    for node in nodes:
        s = node_to_cpp(node, cs, nfs)
        cpp.append(s)
    
    return '\n'.join(cpp)

# A function definition
# https://greentreesnakes.readthedocs.io/en/latest/nodes.html?highlight=call#FunctionDef
# TODO: add support for default values
# TODO: add support for kwargs
# TODO: parse function return type, too
def parse_functionDef(node: ast.FunctionDef) -> Tuple[Variable]:
    pos_args: List[ast.arg] = node.args.args
    kwargs: List[ast.arg] = node.args.kwonlyargs

    variables = []
    for arg in pos_args:
        arg_name: str = arg.arg
        assert isinstance(arg.annotation, ast.Name)
        arg_type = string_to_poptypes_map[arg.annotation.id]
        variables.append(Variable(arg_name, arg_type))


    return tuple(variables)

def write_pyops_cpp(native_functions):
    # TODO: acquire functions programmatically
    src = inspect.getsource(dstack)
    tree = ast.parse(src)

    assert len(tree.body) == 1
    fn_node = tree.body[0]

    parameters = parse_functionDef(fn_node)
    ns = NameState(native_functions)

    # Inserts parameters into names
    for param in parameters:
        ns.add_variable(param.name, param.popType)
    
    nodes = []
    for node in fn_node.body:
        nds = parse_node(node, ns)
        nodes.extend(nds)

    # TODO: add semicolons
    cpp = nodes_to_cpp(nodes, native_functions)
    

    # Auto-generates out variant
    return_node = nodes[-1]
    assert return_node.fn_name == 'return'
    returned_arg = return_node.args[0]
    for node in nodes[::-1]:
        # Finds ultimate torch call producing the return value (if any)
        if (isinstance(node, PopCall) and 
                node.popModule is popModules.torch and 
                node.store == returned_arg):

            try:
                match_nf(node.fn_name, node.args, native_functions, require_out=True)
                # Performs surgey
                # Adds result as an out= arg to the last call
                node.kwargs['out'] = Variable('result', popTypes.Tensor)
                
                # Removes return
                out_nodes = nodes[:-1]

                # Creates cpp
                out_cpp = nodes_to_cpp(out_nodes, native_functions)
                cpp = cpp + "\n\n// out variant\n" + out_cpp
            except Exception as ex:
                # Failed to match an out variant!
                print(ex)
                pass
            finally:
                break

    
    return cpp
